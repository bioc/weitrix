---
title: "poly(A) tail length"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tail_length}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

poly(A) tail length of transcripts can be measured using the [PAT-Seq protocol](https://rnajournal.cshlp.org/content/21/8/1502.long). This protocol produces 3'-end focussed reads that include the poly(A) tail. We examine [GSE83162](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE83162). This is a time-series experiment in which two strains of yeast are released into synchronized cell cycling and observed through two cycles. Yeast are treated with $\alpha$-factor, which causes them to stop dividing in antici... pation of a chance to mate. When the $\alpha$-factor is washed away, they resume cycling.

# Download files

```{r echo=F}
knitr::opts_chunk$set(fig.width=6, fig.height=4, cache=TRUE, autodep=TRUE)

# To examine objects:
# devtools::load_all(".", export_all=F) ; qwraps2::lazyload_cache_dir("vignettes/tail_length_cache/html")

# Produce consistent results
set.seed(12345)
```

```{r download}
if (!file.exists("GSE83162_tail.csv.gz"))
    download.file(
        "https://ftp.ncbi.nlm.nih.gov/geo/series/GSE83nnn/GSE83162/suppl/GSE83162_tail.csv.gz",
        "GSE83162_tail.csv.gz")

if (!file.exists("GSE83162_tail_count.csv.gz"))
    download.file(
        "https://ftp.ncbi.nlm.nih.gov/geo/series/GSE83nnn/GSE83162/suppl/GSE83162_tail_count.csv.gz",
        "GSE83162_tail_count.csv.gz")
```

# Read files, extract experimental design from sample names

```{r load, message=F}
library(tidyverse)
library(reshape2)
library(SummarizedExperiment)
library(limma)
library(topconfects)
library(org.Sc.sgd.db)
library(weitrix)

tail <- read_csv("GSE83162_tail.csv.gz") %>%
    column_to_rownames("Feature") %>%
    as.matrix()
tail_count <- read_csv("GSE83162_tail_count.csv.gz") %>%
    column_to_rownames("Feature") %>%
    as.matrix()
    
samples <- data.frame(sample=I(colnames(tail))) %>%
    extract(sample, c("strain","time"), c("(.+)-(.+)"), remove=FALSE) %>%
    mutate(
        strain=factor(strain,unique(strain)), 
        time=factor(time,unique(time)))
rownames(samples) <- colnames(tail)

samples
```

"tpre" is the cells in an unsynchronized state, other times are minutes after release into cycling.

The two strains are a wildtype and a straing with a mutated set1 gene.


# Create weitrix object

From experience, noise scales with the length of the tail. Therefore to stabilize the variance we will be examing log2 of the tail length.

These tail lengths are each the average over many reads. We therefore weight each tail length by the number of reads. (This is somewhat overoptimistic, as there is biological noise that doesn't go away with more reads. We will approximately correct for this in a later calibration step.)


```{r weitrix, message=F}
log2_tail <- log2(tail)

good <- rowMeans(tail_count) >= 10
table(good)

wei <- as_weitrix(
    log2_tail[good,,drop=F], 
    weights=tail_count[good,,drop=F])

rowData(wei)$gene <- select(org.Sc.sgd.db, keys=rownames(wei), columns=c("GENENAME"))$GENENAME
rowData(wei)$total_reads <- rowSums(weitrix_weights(wei))
colData(wei) <- cbind(colData(wei), samples)
```

# Testing using experimental design

The lack of replicates makes life difficult. For simplicity here we will assume time and strain are independent.

```{r cal}
design <- model.matrix(~ strain + time, data=colData(wei))
```

## Calibration

Our first step is to calibrate our weights. Our weights are overoptimistic for large numbers of reads, as there is a biological components of noise that does not go away with more reads.

The first step of calibration is to have a fitted model, so that we can calculate the residual noise. We will use `weitrix_components`, but won't will supply the design matrix rather than asking it to discover components, making this step similar to limma's lmFit step. This produces a `Components` object containing an approximate matrix decomposition of our tail lengths and will serve as our fitted model.

```{r}
comp_design <- weitrix_components(wei, p=0, design=design)
```

We use `comp_design` as a model while calibrating out the overdispersion due to biological noise. Note: the dispersion shown is *after taking into account weights*.

```{r}
cal_design <- weitrix_calibrate_trend(wei, comp_design, ~splines::ns(log2(total_reads),3))
```

## Examining the effect of calibration

Let's unpack what happens in that `weitrix_calibrate_trend` step.

```{r disp-calc}
rowData(cal_design)$dispersion_unweighted <- weitrix_dispersions(weitrix_x(wei), comp_design)
rowData(cal_design)$dispersion_weighted <- weitrix_dispersions(wei, comp_design)
rowData(cal_design)$dispersion_calibrated <- weitrix_dispersions(cal_design, comp_design)
```

Consider first the dispersion if weights were uniform. Missing data is weighted 0, all other weights are 1.

```{r disp-plot-unif}
rowData(cal_design) %>% as.data.frame() %>%
    ggplot(aes(x=total_reads, y=dispersion_unweighted)) + geom_point(size=0.1) +
    scale_x_log10() + scale_y_log10() +
    labs(title="Dispersion if uniform weights used (log scales)")
```

There is information from the number of reads that we can remove.

Here are the dispersions using read-counts as weights.

```{r disp-plot-weighted}
rowData(cal_design) %>% as.data.frame() %>%
    ggplot(aes(x=total_reads, y=dispersion_weighted)) + geom_point(size=0.1) +
    geom_line(aes(y=dispersion_trend), color="red") +
    scale_x_log10() + scale_y_log10() +
    labs(title="Dispersion with read-counts as weights (log scales)")
```

In general it is improved, but now we have the opposite problem. There is a component of noise that does not go away with more and more reads. The red line is a trend fitted to this, which `weitrix_calibrate_trend` divides out of the weights.

Finally, here are the dispersion from the calibrated weitrix.

```{r disp-plot-cal}
rowData(cal_design) %>% as.data.frame() %>%
    ggplot(aes(x=total_reads, y=dispersion_calibrated)) + geom_point(size=0.1) +
    scale_x_log10() + scale_y_log10() +
    labs(title="Dispersion with read-count weights / trend-based calibration\n(log scales)")
```

This is reasonably close to uniform, with no trend from the number of reads. `limma` can now estimate the variability of dispersions between genes, and apply its Emprical-Bayes squeezed dispersion based testing.

## Testing

We are now ready to test things. We feed our calibrated weitrix to [limma](https://bioconductor.org/packages/release/bioc/html/limma.html) and then to [topconfects](https://bioconductor.org/packages/release/bioc/html/topconfects.html).

```{r limmadesign}
fit_cal_design <- cal_design %>%
    weitrix_elist() %>%
    lmFit(design)

limma_confects(fit_cal_design, "strainDeltaSet1", full=TRUE, fdr=0.05)
```

This lists the largest confident log2 fold changes in poly(A) tail length. These confidence bounds are adjusted for multiple testing.

Column | Description
---: | ---
confect | Confident bound on the log2 fold change in tail length (including adjustment for multiple testing)
effect | Estimated log2 fold change in tail length
se | Standard error of estimate
df | Degreees of freedom, including Emprical-Bayes prior
fdr_zero | FDR-adjust p-value that the change is non-zero (i.e. the traditional result from differential testing)
AveExpr | A misnomer, actually the average log2 tail length

We could just as well use `limma::topTable`, which by default would give results sorted by the `fdr_zero` values in the table above.

Note that due to PCR amplification slippage and limited read length, the observed log2 poly(A) tail lengths may be an underestimate. However as all samples have been prepared in the same way, observed differences should indicate the existence of true differences.


# Exploratory analysis

We can also look for components of variation.

```{r comp, message=F}
comp_seq <- weitrix_components_seq(wei, p=10)
```

```{r scree}
components_seq_screeplot(comp_seq)
```

Three components seems reasonable.

```{r exam}
comp <- comp_seq[[3]]

comp$col[,-1] %>% melt(varnames=c("sample","component")) %>%
    left_join(samples,by="sample") %>%
    ggplot(aes(x=time, y=value, color=strain, group=strain)) + 
    geom_hline(yintercept=0) + 
    geom_line() + 
    geom_point(alpha=0.75, size=3) + 
    facet_grid(component ~ .) +
    labs(title="Sample scores for each component", y="Sample score", x="Time", color="Strain")
```

We observe:

* C1 - A gradual lengthening of tails after release into cell cycling. (The reason for the divergence between strains at the end is unclear.)
* C2 - A lengthening of poly(A) tails in the set1 mutant.
* C3 - Variation in poly(A) tail length with the cell cycle.

The log2 tail lengths are approximated by `comp$row %*% t(comp$col)` where `comp$col` is an $n_\text{sample} \times (p+1)$ matrix of scores (shown above), and `comp$row` is an $n_\text{gene} \times (p+1)$ matrix of gene loadings, which we will now examine. (The $+1$ is the intercept "component", allowing each gene to have a different baseline tail length.)

```{r limmacomp}
cal_comp <- weitrix_calibrate_trend(wei, comp, ~splines::ns(log2(total_reads),3))
fit_comp <- cal_comp %>%
    weitrix_elist() %>%
    lmFit(comp$col)
```

**Treat these results with caution.** Confindence bounds take into account uncertainty in the loadings but not in the scores! What follows is best regarded as exploratory rather than a final result.

## Gene loadings for C1: gradual lengthing over time

```{r C1}
limma_confects(fit_comp, "C1", full=TRUE, fdr=0.05)
```

FUS3 is involved in yeast mating. We see here a poly(A) tail signature of yeast realizing there are not actually any $\alpha$ cells around to mate with.

## Gene loadings for C2: longer tails in set1 mutant

```{r C2}
limma_confects(fit_comp, "C2", full=TRUE, fdr=0.05)
```

## Gene loadings for C3: cell-cycle associated changes

```{r C3}
limma_confects(fit_comp, "C3", full=TRUE, fdr=0.05)
```

Given the mixture of signs for effects in C3, different genes are longer in different stages of the cell cycle. We see many genes to do with replication, and also Mating Factor A.


## Check individual genes

Having discovered patterns of tail length change and their associated genes, let's look at some genes in detail.

```{r check}
view_gene <- function(id, title) {
    ggplot(samples, aes(x=time,color=strain,group=strain, 
        y=tail[id,])) +
       geom_line() + geom_point(aes(size=tail_count[id,])) +
       labs(x="Time", y="Tail length", size="Read count", title=title)
}

view_gene("YBL016W", "FUS3 (C1)")
view_gene("YOR096W", "RPS7A (C1)")
view_gene("YDR092W", "UBC1 (C1)")
view_gene("YDR476C","YDR476C (C2)")
view_gene("YPL131W","RPL5 (C2)")
view_gene("YCR014C","POL4 (C2)")
view_gene("YFL014W", "HSP12 (C3)")
view_gene("YBL003C","HTA2 (C3)")
view_gene("YDR461W", "MFA1 (C3)")
```







